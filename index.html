<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="th0_sky'home">
<meta property="og:url" content="http://th0sky.top/index.html">
<meta property="og:site_name" content="th0_sky'home">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="th0_sky'home">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://th0sky.top/"/>

  <title> th0_sky'home </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">th0_sky'home</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="2016/10/01/Android面试-md/" itemprop="url">
                  Android面试.md
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-01T17:46:18+08:00" content="2016-10-01">
              2016-10-01
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Android：</p>
<p><strong>五种布局： FrameLayout 、 LinearLayout 、 AbsoluteLayout 、 RelativeLayout 、 TableLayout 全都继承自ViewGroup，各自特点及绘制效率对比。</strong></p>
<ul>
<li><p>FrameLayout(框架布局)</p>
<p>  此布局是五中布局中最简单的布局，Android中并没有对child view的摆布进行控制，这个布局中所有的控件都会默认出现在视图的左上角，我们可以使用<code>android:layout_margin</code>，<code>android:layout_gravity</code>等属性去控制子控件相对布局的位置。</p>
</li>
<li><p>LinearLayout(线性布局)</p>
<p>  一行只控制一个控件的线性布局，所以当有很多控件需要在一个界面中列出时，可以用LinearLayout布局。<br>  此布局有一个需要格外注意的属性:<code>android:orientation=“horizontal|vertical</code>。</p>
<ul>
<li>当<code>android:orientation=&quot;horizontal</code>时，<em>说明你希望将水平方向的布局交给<strong>LinearLayout</strong> </em>，其子元素的<code>android:layout_gravity=&quot;right|left&quot;</code> 等控制水平方向的gravity值都是被忽略的，<em>此时<strong>LinearLayout</strong>中的子元素都是默认的按照水平从左向右来排</em>，我们可以用<code>android:layout_gravity=&quot;top|bottom&quot;</code>等gravity值来控制垂直展示。</li>
<li>反之，可以知道 当<code>android:orientation=&quot;vertical</code>时，<strong>LinearLayout</strong>对其子元素展示上的的处理方式。</li>
</ul>
</li>
<li><p>AbsoluteLayout(绝对布局)</p>
<p>  可以放置多个控件，并且可以自己定义控件的x,y位置</p>
</li>
<li><p>RelativeLayout(相对布局)</p>
<p>  这个布局也是相对自由的布局，Android 对该布局的child view的 水平layout&amp; 垂直layout做了解析，由此我们可以FrameLayout的基础上使用标签或者Java代码对垂直方向 以及 水平方向 布局中的views任意的控制.</p>
<ul>
<li><p>相关属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line">    　android:layout_centerInParent=&quot;true|false&quot;</div><div class="line">	　　android:layout_centerHorizontal=&quot;true|false&quot;</div><div class="line">	　　android:layout_alignParentRight=&quot;true|false&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>TableLayout(表格布局)</p>
<p>  将子元素的位置分配到行或列中，一个TableLayout由许多的TableRow组成</p>
</li>
</ul>
<hr>
<p><strong>Activity生命周期。</strong></p>
<ul>
<li>启动Activity:<br>onCreate()—&gt;onStart()—&gt;onResume()，Activity进入运行状态。</li>
<li>Activity退居后台:<br>当前Activity转到新的Activity界面或按Home键回到主屏：<br>onPause()—&gt;onStop()，进入停滞状态。</li>
<li>Activity返回前台:<br>onRestart()—&gt;<strong>onStart()</strong>—&gt;onResume()，再次回到运行状态。</li>
<li>Activity退居后台，且系统内存不足，<br><em>系统会杀死这个后台状态的Activity（此时这个Activity引用仍然处在任务栈中，只是这个时候引用指向的对象已经为null），若再次回到这个Activity,则会走onCreate()–&gt;onStart()—&gt;onResume()(将重新走一次Activity的初始化生命周期)</em></li>
<li><p>锁定屏与解锁屏幕<br><strong>只会调用onPause()，而不会调用onStop()方法，开屏后则调用onResume()</strong></p>
</li>
<li><p>更多流程分支，请参照以下生命周期流程图<br>  <img src="http://img.blog.csdn.net/20130828141902812" alt=""></p>
</li>
</ul>
<hr>
<p><strong>Fragment生命周期</strong></p>
<p><img src="http://7xntdm.com1.z0.glb.clouddn.com/fragment_lifecycle.png" alt=""></p>
<p>注意和Activity的相比的区别,按照执行顺序<!----></p>
<ul>
<li>onAttach(),onDetach()</li>
<li>onCreateView(),onDestroyView()</li>
</ul>
<hr>
<p><strong>Fragment的生命周期和activity如何的一个关系</strong></p>
<p>这我们引用本知识库里的一张图片：<br><img src="https://github.com/GeniusVJR/LearningNotes/blob/master/Part1/Android/FlowchartDiagram.jpg?raw=true" alt="Mou icon"></p>
<hr>
<p><strong>通过Acitivty的xml标签来改变任务栈的默认行为</strong></p>
<ul>
<li><p>使用<code>android:launchMode=&quot;standard|singleInstance|singleTask|singleTop&quot;</code>来控制Acivity任务栈。</p>
<p>  <strong>任务栈</strong>是一种后进先出的结构。位于栈顶的Activity处于焦点状态,当按下back按钮的时候,栈内的Activity会一个一个的出栈,并且调用其<code>onDestory()</code>方法。如果栈内没有Activity,那么系统就会回收这个栈,每个APP默认只有一个栈,以APP的包名来命名.</p>
<ul>
<li>standard : 标准模式,每次启动Activity都会创建一个新的Activity实例,并且将其压入任务栈栈顶,而不管这个Activity是否已经存在。Activity的启动三回调(<em>onCreate()-&gt;onStart()-&gt;onResume()</em>)都会执行。</li>
</ul>
<ul>
<li>singleTop : 栈顶复用模式.这种模式下,如果新Activity已经位于任务栈的栈顶,那么此Activity不会被重新创建,所以它的启动三回调就不会执行,同时Activity的<code>onNewIntent()</code>方法会被回调.如果Activity已经存在但是不在栈顶,那么作用于<em>standard模式</em>一样.</li>
<li>singleTask: 栈内复用模式.创建这样的Activity的时候,系统会先确认它所需任务栈已经创建,否则先创建任务栈.然后放入Activity,如果栈中已经有一个Activity实例,那么这个Activity就会被调到栈顶,<code>onNewIntent()</code>,并且singleTask会清理在当前Activity上面的所有Activity.(clear top)</li>
<li>singleInstance : 加强版的singleTask模式,这种模式的Activity只能单独位于一个任务栈内,由于栈内复用的特性,后续请求均不会创建新的Activity,除非这个独特的任务栈被系统销毁了</li>
</ul>
</li>
</ul>
<p>Activity的堆栈管理以ActivityRecord为单位,所有的ActivityRecord都放在一个List里面.可以认为一个ActivityRecord就是一个Activity栈</p>
<hr>
<p><strong>Activity缓存方法。</strong></p>
<p>有a、b两个Activity，当从a进入b之后一段时间，可能系统会把a回收，这时候按back，执行的不是a的onRestart而是onCreate方法，a被重新创建一次，这是a中的临时数据和状态可能就丢失了。</p>
<p>可以用Activity中的onSaveInstanceState()回调方法保存临时数据和状态，这个方法一定会在活动被回收之前调用。方法中有一个Bundle参数，putString()、putInt()等方法需要传入两个参数，一个键一个值。数据保存之后会在onCreate中恢复，onCreate也有一个Bundle类型的参数。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">    //这里，当Acivity第一次被创建的时候为空</div><div class="line">    //所以我们需要判断一下</div><div class="line">    if( savedInstanceState != null )&#123;</div><div class="line">        savedInstanceState.getString(&quot;anAnt&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onSaveInstanceState(Bundle outState) &#123;</div><div class="line">    super.onSaveInstanceState(outState);</div><div class="line"></div><div class="line">    outState.putString(&quot;anAnt&quot;,&quot;Android&quot;);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一、onSaveInstanceState (Bundle outState)</p>
<p>当某个activity变得“容易”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户主动销毁的，例如当用户按BACK键的时候。</p>
<p>注意上面的双引号，何为“容易”？言下之意就是该activity还没有被销毁，而仅仅是一种可能性。这种可能性有哪些？通过重写一个activity的所有生命周期的onXXX方法，包括onSaveInstanceState和onRestoreInstanceState方法，我们可以清楚地知道当某个activity（假定为activity A）显示在当前task的最上层时，其onSaveInstanceState方法会在什么时候被执行，有这么几种情况：</p>
<ol>
<li><p>当用户按下HOME键时。<br>这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，故系统会调用onSaveInstanceState，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则</p>
</li>
<li><p>长按HOME键，选择运行其他的程序时。</p>
</li>
<li><p>按下电源按键（关闭屏幕显示）时。</p>
</li>
<li><p>从activity A中启动一个新的activity时。</p>
</li>
<li><p>屏幕方向切换时，例如从竖屏切换到横屏时。（如果不指定configchange属性）<br>在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行</p>
</li>
</ol>
<p>总而言之，onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据（当然你不保存那就随便你了）。另外，需要注意的几点：</p>
<ol>
<li><p>布局中的每一个View默认实现了<code>onSaveInstanceState()</code>方法，这样的话，这个UI的任何改变都会自动的存储和在activity重新创建的时候自动的恢复。但是这种情况只有在你为这个UI提供了唯一的ID之后才起作用，如果没有提供ID，将不会存储它的状态。</p>
</li>
<li><p>由于默认的<code>onSaveInstanceState()</code>方法的实现帮助UI存储它的状态，所以如果你需要覆盖这个方法去存储额外的状态信息时，你应该在执行任何代码之前都调用父类的<code>onSaveInstanceState()</code>方法<code>super.onSaveInstanceState()</code>。既然有现成的可用，那么我们到底还要不要自己实现<code>onSaveInstanceState()</code>?这得看情况了，如果你自己的派生类中有变量影响到UI，或你程序的行为，当然就要把这个变量也保存了，那么就需要自己实现，否则就不需要。</p>
</li>
<li><p>由于<code>onSaveInstanceState()</code>方法调用的不确定性，你应该只使用这个方法去记录activity的瞬间状态（UI的状态，比如用户输入的表单信息）。不应该用这个方法去存储持久化数据。当用户离开这个activity的时候应该在<code>onPause()</code>方法中存储持久化数据（例如应该被存储到数据库中的数据）。</p>
</li>
<li><p><code>onSaveInstanceState()</code>如果被调用，这个方法会在<code>onStop()</code>前被触发，但系统并不保证是否在<code>onPause()</code>之前或者之后触发。</p>
</li>
</ol>
<p>二、onRestoreInstanceState (Bundle outState)</p>
<p>至于onRestoreInstanceState方法，需要注意的是，onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的，（本人注：我昨晚调试时就发现原来不一定成对被调用的！）</p>
<p>onRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行</p>
<p>另外，onRestoreInstanceState的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。还有onRestoreInstanceState在onstart之后执行。<br>至于这两个函数的使用，给出示范代码（留意自定义代码在调用super的前或后，语句放在super的前或后，要具体看希望什么时候执行父类的方法，在Android中，会有一些必要的初始化的工作在父类执行，故一般在<code>onCreate(),onStart(),onResume()</code>中先调super后写自己的语句，在销毁的时候，系统需要做些回收的工作，故在 <code>onPause(),onStop(),onDestory()</code>中先写自己语句再调super。进的时候super先进，退的时候super后退）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onSaveInstanceState(Bundle savedInstanceState) &#123;</div><div class="line">        savedInstanceState.putBoolean(&quot;MyBoolean&quot;, true);</div><div class="line">        savedInstanceState.putDouble(&quot;myDouble&quot;, 1.9);</div><div class="line">        savedInstanceState.putInt(&quot;MyInt&quot;, 1);</div><div class="line">        savedInstanceState.putString(&quot;MyString&quot;, &quot;Welcome back to Android&quot;);</div><div class="line">        // etc.</div><div class="line">        super.onSaveInstanceState(savedInstanceState);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void onRestoreInstanceState(Bundle savedInstanceState) &#123;</div><div class="line">        super.onRestoreInstanceState(savedInstanceState);</div><div class="line"></div><div class="line">        boolean myBoolean = savedInstanceState.getBoolean(&quot;MyBoolean&quot;);</div><div class="line">        double myDouble = savedInstanceState.getDouble(&quot;myDouble&quot;);</div><div class="line">        int myInt = savedInstanceState.getInt(&quot;MyInt&quot;);</div><div class="line">        String myString = savedInstanceState.getString(&quot;MyString&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>为什么在Service中创建子线程而不是Activity中</strong></p>
<p>这是因为Activity很难对Thread进行控制，当Activity被销毁之后，就没有任何其它的办法可以再重新获取到之前创建的子线程的实例。而且在一个Activity中创建的子线程，另一个Activity无法对其进行操作。但是Service就不同了，所有的Activity都可以与Service进行关联，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。</p>
<p><strong>Intent的使用方法，可以传递哪些数据类型。</strong></p>
<p>通过查询Intent/Bundle的API文档，我们可以获知，Intent/Bundle支持传递基本类型的数据和基本类型的数组数据，以及String/CharSequence类型的数据和String/CharSequence类型的数组数据。而对于其它类型的数据貌似无能为力，其实不然，我们可以在Intent/Bundle的API中看到Intent/Bundle还可以传递Parcelable（包裹化，邮包）和Serializable（序列化）类型的数据，以及它们的数组/列表数据。</p>
<p>所以要让非基本类型和非String/CharSequence类型的数据通过Intent/Bundle来进行传输，我们就需要在数据类型中实现Parcelable接口或是Serializable接口。</p>
<p><a href="http://blog.csdn.net/kkk0526/article/details/7214247" target="_blank" rel="external">http://blog.csdn.net/kkk0526/article/details/7214247</a></p>
<hr>
<p><strong>Service的两种启动方法，有什么区别</strong></p>
<p>1.在Context中通过<code>public boolean bindService(Intent service,ServiceConnection conn,int flags)</code> 方法来进行Service与Context的关联并启动，并且Service的生命周期依附于Context(<strong>不求同时同分同秒生！但求同时同分同秒屎！！</strong>)。</p>
<p>2.通过<code>public ComponentName startService(Intent service)</code>方法去启动一个Service，此时Service的生命周期与启动它的Context无关。</p>
<p>3.要注意的是，whatever，<strong>都需要在xml里注册你的Service</strong>，就像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;service</div><div class="line">    android:name=&quot;.packnameName.youServiceName&quot;</div><div class="line">    android:enabled=&quot;true&quot; /&gt;</div></pre></td></tr></table></figure>
<p><strong>广播(Boardcast Receiver)的两种动态注册和静态注册有什么区别。</strong></p>
<ul>
<li>静态注册：在AndroidManifest.xml文件中进行注册，当App退出后，Receiver仍然可以接收到广播并且进行相应的处理</li>
<li>动态注册：在代码中动态注册，当App退出后，也就没办法再接受广播了</li>
</ul>
<hr>
<p><strong>目前能否保证service不被杀死</strong></p>
<p><strong>Service设置成START_STICKY</strong></p>
<ul>
<li>kill 后会被重启（等待5秒左右），重传Intent，保持与重启前一样</li>
</ul>
<p><strong>提升service优先级</strong></p>
<ul>
<li>在AndroidManifest.xml文件中对于intent-filter可以通过<code>android:priority = &quot;1000&quot;</code>这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，<strong>同时适用于广播</strong>。</li>
<li>【结论】目前看来，priority这个属性貌似只适用于broadcast，对于Service来说可能无效</li>
</ul>
<p><strong>提升service进程优先级</strong></p>
<ul>
<li>Android中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进行进程的回收</li>
<li>当service运行在低内存的环境时，将会kill掉一些存在的进程。因此进程的优先级将会很重要，可以在startForeground()使用startForeground()将service放到前台状态。这样在低内存时被kill的几率会低一些。</li>
<li>【结论】如果在极度极度低内存的压力下，该service还是会被kill掉，并且不一定会restart()</li>
</ul>
<p><strong>onDestroy方法里重启service</strong></p>
<ul>
<li>service +broadcast  方式，就是当service走ondestory()的时候，发送一个自定义的广播，当收到广播的时候，重新启动service</li>
<li>也可以直接在onDestroy()里startService</li>
<li>【结论】当使用类似口口管家等第三方应用或是在setting里-应用-强制停止时，APP进程可能就直接被干掉了，onDestroy方法都进不来，所以还是无法保证</li>
</ul>
<p><strong>监听系统广播判断Service状态</strong></p>
<ul>
<li>通过系统的一些广播，比如：手机重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的Service是否还存活，别忘记加权限</li>
<li>【结论】这也能算是一种措施，不过感觉监听多了会导致Service很混乱，带来诸多不便</li>
</ul>
<p><strong>在JNI层,用C代码fork一个进程出来</strong></p>
<ul>
<li>这样产生的进程,会被系统认为是两个不同的进程.但是Android5.0之后可能不行</li>
</ul>
<p><strong>root之后放到system/app变成系统级应用</strong></p>
<p><strong>大招: 放一个像素在前台(手机QQ)</strong></p>
<hr>
<hr>
<p><strong>Android的数据存储形式。</strong></p>
<ul>
<li><p>SQLite：SQLite是一个轻量级的数据库，支持基本的SQL语法，是常被采用的一种数据存储方式。<br>Android为此数据库提供了一个名为SQLiteDatabase的类，封装了一些操作数据库的api</p>
</li>
<li><p>SharedPreference： 除SQLite数据库外，另一种常用的数据存储方式，其本质就是一个xml文件，常用于存储较简单的参数设置。</p>
</li>
<li><p>File： 即常说的文件（I/O）存储方法，常用语存储大数量的数据，但是缺点是更新数据将是一件困难的事情。</p>
</li>
<li><p>ContentProvider: Android系统中能实现所有应用程序共享的一种数据存储方式，由于数据通常在各应用间的是互相私密的，所以此存储方式较少使用，但是其又是必不可少的一种存储方式。例如音频，视频，图片和通讯录，一般都可以采用此种方式进行存储。每个Content Provider都会对外提供一个公共的URI（包装成Uri对象），如果应用程序有数据需要共享时，就需要使用Content Provider为这些数据定义一个URI，然后其他的应用程序就通过Content Provider传入这个URI来对数据进行操作。</p>
</li>
</ul>
<hr>
<p><strong>如何判断应用被强杀</strong></p>
<p>在Application中定义一个static常量，赋值为－1，在欢迎界面改为0，如果被强杀，application重新初始化，在父类Activity判断该常量的值。</p>
<p><strong>应用被强杀如何解决</strong></p>
<p>如果在每一个Activity的onCreate里判断是否被强杀，冗余了，封装到Activity的父类中，如果被强杀，跳转回主界面，如果没有被强杀，执行Activity的初始化操作，给主界面传递intent参数，主界面会调用onNewIntent方法，在onNewIntent跳转到欢迎页面，重新来一遍流程。</p>
<p><strong>Json有什么优劣势。</strong></p>
<ol>
<li><p>优势</p>
<ul>
<li>数据格式简单，易于读写</li>
<li>解析难度低，速度快</li>
<li>支持多种语言</li>
</ul>
</li>
<li><p>劣势</p>
<ul>
<li>没有XML那么通用</li>
</ul>
</li>
</ol>
<p><strong>怎样退出终止App</strong></p>
<ol>
<li>建立一个全局容器，把所有Activity存储起来，退出时循环遍历finish所有Activity</li>
<li>广播＋singleTask 把MainActivity的启动模式设置为singleTask ，在MainActivity中注册一个退出广播。退出时只需要 <code>startActivity(this,MainActivity)</code>,然后再发送一个退出广播。 这样会把栈中MainActivity之上的所有Activity移除出栈，然后广播finish自己。</li>
</ol>
<p><strong>Asset目录与res目录的区别。</strong></p>
<p>Asset：不会映射到R文件中去；必须使用AssetsManager进行访问；不会被编译成二进制，</p>
<p>res：会映射到R文件中去，直接使用资源ID来访问<br>res/raw::该目录下的文件可以直接复制到设备上,不会被编译成二进制</p>
<p><strong>ListView优化</strong></p>
<ol>
<li>复用convertView</li>
<li>使用ViewHolder</li>
<li>item中有图片时，异步加载并对图片进行适当的压缩</li>
<li>快速滑动时，不要加载图片</li>
<li>分批和分页加载</li>
</ol>
<p><strong>谈谈RecyclerView，以及不使用recyclerview如何实现瀑布流</strong> </p>
<p> 对比</p>
<ul>
<li><p>布局效果</p>
<p>  RecyclerView 本身就支持 线性布局、网格布局、瀑布流布局。而且还能控制横行滚动，纵向滚动。核心在于<code>RecyclerView.LayoutManager</code>。<code>LayoutManager</code> 只是一个抽象类而已，系统已经为我们提供了三个相关的实现类 LinearLayoutManager（线性布局效果）、<code>GridLayoutManager</code>（网格布局效果）、<code>StaggeredGridLayoutManager</code>（瀑布流布局效果）。如果你想用 RecyclerView 来实现自己 YY 出来的一种效果，则应该去继承实现自己的 LayoutManager，并重写相应的方法，而不应该想着去改写 RecyclerView。</p>
</li>
<li><p>局部刷新</p>
<p> <code>RecyclerView.Adapter</code> 则我们提供了 <code>notifyItemChanged</code> 用于更新单个ItemView的刷新，我们可以省去自己写局部更新的工作。</p>
<p> ListView的局部刷新得自己完成：</p>
</li>
</ul>
<figure class="highlight plain"><figcaption><span>void updateItemView(ListView listView, int position) &#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">    //换算成 Item View 在 ViewGroup 中的 index</div><div class="line">    int index = position - listView.getFirstVisiblePosition();</div><div class="line">    if (index &gt;= 0 &amp;&amp; index &lt; listView.getChildCount()) &#123;</div><div class="line">        //更新数据</div><div class="line">        AuthorInfo authorInfo = mAuthorInfoList.get(position);</div><div class="line">        authorInfo.setNickName(&quot;Google Android&quot;);</div><div class="line">        authorInfo.setMotto(&quot;My name is Android .&quot;);</div><div class="line">        authorInfo.setPortrait(R.mipmap.ic_launcher);</div><div class="line">        //更新单个Item</div><div class="line">        View itemView = listView.getChildAt(index);</div><div class="line">        getView(position, itemView, listView);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>空数据的处理</p>
<p>ListView提供了<code>setEmptyView()</code>这个 API 来让我们处理 Adapter 中数据为空的情况.<br>RecyclerView则没有提供此类api，得自己来完成</p>
</li>
</ul>
<ul>
<li><p>HeadView和FooterView</p>
<p>ListView提供了api来设置HeadView和FooterView。这样的好处是：当我们指向在 ListView 的头部或者底部添加一个 View 的时候（例如：添加一个下拉刷新视图，底部加载更多视图），我们可以不用影响到 Adapter 的编写，使用起来相当方便。</p>
<p>RecyclerView则没有提供此类api，得自己来完成。比如就是在 Adapter 中提供三种类型（Header，Footer以及普通Item）的 Type 和 View。</p>
</li>
</ul>
<ul>
<li><p>监听item事件</p>
<p>  ListView为item提供了单击，长按等回调接口</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setOnItemClickListener()</div><div class="line">setOnItemLongClickListener()</div><div class="line">setOnItemSelectedListener()</div></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>RecyclerView没有提供此类api，（本质上给每个item添加onClickListener来模仿一个伪onItemClickListener）。
</code></pre><ul>
<li><p>嵌套滑动机制</p>
<p>  RecyclerView实现了嵌套滑动机制而listview没有实现</p>
</li>
</ul>
<p><strong>嵌套滑动机制（NestedScrolling）</strong></p>
<p>NestedScrolling 提供了一套父 View 和子 View 滑动交互机制。要完成这样的交互，父View 需要实现 <code>NestedScrollingParent</code> 接口，而子View需要实现 <code>NestedScrollingChild</code> 接口。实现这两个接口可以通过这两个辅助类NestedScrollingChildHelper，NestedScrollingParentHelper很方便的完成</p>
<ul>
<li>交互流程</li>
</ul>
<p>本质上NestedScrolling就是：子View在滚动的时候，首先将dx,dy交给父view，父view可对其进行部分消耗，剩余的部分还给子View。</p>
<table>
<thead>
<tr>
<th>子view</th>
<th>父view</th>
</tr>
</thead>
<tbody>
<tr>
<td>startNestedScroll</td>
<td>onStartNestedScroll、onNestedScrollAccepted</td>
</tr>
<tr>
<td>dispatchNestedPreScroll</td>
<td>onNestedPreScroll</td>
</tr>
<tr>
<td>dispatchNestedScroll</td>
<td>onNestedScroll</td>
</tr>
<tr>
<td>stopNestedScroll</td>
<td>onStopNestedScroll</td>
</tr>
</tbody>
</table>
<ol>
<li><p>startNestedScroll</p>
<p>首先由子view开启整个流程(在子View的onInterceptTouchEvent中的ACTION_DOWN事件)，通知父view，我需要你配合处理TouchEvent。</p>
<p>父view会收到onStartNestedScroll的回调，决定是否要配合子view一起处理滑动，如果需要配合，还会回调onNestedScrollAccepted</p>
</li>
</ol>
<ol>
<li><p>dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow)</p>
<p>每次滑动前(在子View的onInterceptTouchEvent中,一般在MontionEvent.ACTION_MOVE事件里)，子view先询问父view是否需要滑动，即调用dispatchNestedPreScroll。<br>该方法的第三第四个参数返回父view消费掉的scroll长度和子View的窗体偏移量。如果这个scroll没有被消费完，则子view进行处理剩下的一些距离。</p>
<p>如果父view接受了它的滚动参数，进行了部分消费（即回调onNestedPreScroll），则这个函数返回true，否则为false。<br>这个函数一般在子view处理scroll前调用。</p>
</li>
<li><p>dispatchNestedScroll</p>
<p>向父view汇报滚动情况，包括子view消费的部分和子view没有消费的部分。<br>如果父view接受了它的滚动参数，进行了部分消费（即回调onNestedScroll），则这个函数返回true，否则为false。<br>这个函数一般在子view处理scroll后调用。</p>
</li>
</ol>
<ol>
<li><p>stopNestedScroll </p>
<p>结束整个流程 由子view在onInterceptTouchEvent中的ACTION_UP事件中调用</p>
</li>
</ol>
<p><strong>scrollview特点</strong><br><strong>处理listview图片错位方式</strong><br><strong>Mvp与mvc区别，实现，架构表示</strong><br><strong>打包混淆原理</strong><br><strong>jni使用及其原理</strong></p>
<ol>
<li>在java中声明native方法</li>
<li>编译java源文件，然后通过javah命令导出jni头文件</li>
<li>实现jni方法，需要include上一步的头文件</li>
<li>编译so库，并在java中调用</li>
</ol>
<p><strong>ViewPager如何判断左滑右滑</strong><br><code>onPageScrolled(int position,float positionOffset, int positionOffsetPixels)</code>：这个方法会在屏幕滚动过程中不断被调用。<br>positionOffset是当前页面滑动比例，如果页面向右翻动，这个值不断变大，最后在趋近1的情况后突变为0。如果页面向左翻动，这个值不断变小，最后变为0。<br>positionOffsetPixels是当前页面滑动像素，变化情况和positionOffset一致。</p>
<p>可以通过这个参数来判断左滑右滑</p>
<p><strong>使用图片缓存但是服务器改了实际的图片，但url一样，如何在客户端区别</strong><br><strong>Android怎么加速启动Activity</strong><br><strong>Android中弱引用与软引用的应用场景</strong></p>
<p><strong>Bitmap的四种属性，与每种属性队形的大小</strong><br><strong>大图加载问题</strong><br><strong>请介绍下ContentProvider是如何实现数据共享的</strong><br><strong>你看过Android Framework的代码吗?介绍一下某一个或几个模块?</strong><br><strong>说说你做的最复杂的一个控件</strong><br><strong>android开机过程</strong><br><strong>启动一个应用的流程（从点击桌面的icon开始）</strong></p>
<ol>
<li>其实应用的都是从其他应用调用startActivity开始的(Launcher也是一个应用，一个Activity)</li>
<li>然后通过Binder代理对象(ActivityManagerProxy是AMS的代理，供应用进程调用)请求AMS启动Activity</li>
<li>然后AMS创建一个新进程，用来启动一个ActivityThread实例(就是所谓的UI线程，主线程)，之后主线程初始化，主要是实例化ApplicationThread(Binder对象)，以及MainLooper的创建。</li>
<li>应用进程将实例化的ApplicationThreadProxy传递给AMS，这样AMS就可以通过代理对应用进程进行访问</li>
<li>AMS通过代理，请求启动Activity。ApplicationThread通知主线程执行该请求。然后，ActivityThread执行Activity的启动。<br>Activity的启动包括，Activity的实例化，Application的实例化，以及Activity的启动流程：create、start、resume。</li>
</ol>
<p><strong>ListView下拉刷新实现原理</strong></p>
<p>   给ListView添加一个headView，在滚动中时不断改变header的高度和内容并记录一些状态，在用户手指离开屏幕时根据状态决定进行刷新还是放弃刷新。</p>
<p> 主要是通过重写ListView的<code>onTouchEvent</code>和<code>OnScrollListener</code>的<code>onScrollStateChanged</code>，<code>onScroll</code>方法实现的。</p>
<p> 下拉刷新一般有4种状态：</p>
<ol>
<li>CLICK_TO_REFRESH      初始状态</li>
<li>DROP_DOWN_TO_REFRESH  headView下拉的一段距离，但是未到刷新距离</li>
<li>RELEASE_TO_REFRESH    headView已下拉越过刷新线，松手即可刷新</li>
<li>REFRESHING            刷新中</li>
</ol>
<ul>
<li><p><code>onTouchEvent</code>方法</p>
<p>根据用户触发的事件序列，进行相应的操作</p>
<ol>
<li>ACTION_DOWN表示用户手指刚接触屏幕，会记录用户此时touch的点的y坐标，在下面调整高度时使用</li>
<li>ACTION_MOVE表示用户手指正在屏幕上移动，此时会不断调整headView的高度。</li>
<li>ACTION_UP表示用户手指离开屏幕，此时会根据当前状态决定是进行刷新还是放弃刷新，若刷新调用用户设置的OnRefreshListener接口</li>
</ol>
</li>
</ul>
<ul>
<li><p><code>onScrollStateChanged</code>方法 </p>
<p>  记录listView当前的滚动状态到currentScrollState，包括三种状态： </p>
<ol>
<li>SCROLL_STATE_TOUCH_SCROLL ListView正在滚动中，并且手指尚未离开屏幕</li>
<li>SCROLL_STATE_FLING ListView仍在滚动中，但用户手指已经离开屏幕</li>
<li>SCROLL_STATE_IDLE ListView已经停止滚动</li>
</ol>
</li>
<li><p><code>onScroll</code>方法</p>
<p>根据listView当前的滚动状态即currentScrollState和当前刷新的状态currentHeaderStatus不断修改headView的内容显示和刷新状态。</p>
<ol>
<li>滚动状态为SCROLL_STATE_TOUCH_SCROLL(手指按着屏幕滚动中)且刷新状态不为REFRESHING<br> a.  headView(item=0)可见时，若刷新layout高度超出范围，则置刷新状态为RELEASE_TO_REFRESH；若刷新layout高度低于高度范围，则置刷新状态为DROP_DOWN_TO_REFRESH。<br> b.  headView(item=0)不可见时 重置headView</li>
<li>ListView为SCROLL_STATE_FLING状态(松手滚动中)     </li>
</ol>
</li>
</ul>
<p><strong>ContentProvider使用方法</strong></p>
<p><a href="http://blog.csdn.net/juetion/article/details/17481039" target="_blank" rel="external">http://blog.csdn.net/juetion/article/details/17481039</a></p>
<hr>
<p><strong>Sqlite的基本操作。</strong></p>
<p><a href="http://blog.csdn.net/zgljl2012/article/details/44769043" target="_blank" rel="external">http://blog.csdn.net/zgljl2012/article/details/44769043</a></p>
<hr>
<p><strong>动画有哪两类，各有什么特点？三种动画的区别</strong></p>
<p><em>View动画</em> </p>
<p>   通过指定View的初末状态和变化时间、方式，对View的内容完成一系列的图形变换来实现动画效果。</p>
<ul>
<li><p>使用view动画，首先创建动画的xml文件，将其放入res/anim/路径下</p>
</li>
<li><p>View动画的四种变换</p>
<p><translate>：平移动画<br><rotate>：   旋转动画<br><alpha>：    透明度动画<br><scale>：    缩放动画</scale></alpha></rotate></translate></p>
</li>
<li><p><set>表示动画集合，它可以包含上述若干个动画，也可以嵌套其它动画集合。<br> <set>的两个重要属性:</set></set></p>
<pre><code>android:interpolator 表示动画集合采用的插值器，插值器影响动画的速度
android:shareUbterpolator 表示集合中的动画是否共享一个插值器
</code></pre></li>
<li><p>View动画的特殊使用场景： </p>
<ol>
<li><p>LayoutAnimation：作用于ViewGroup，为ViewGroup指定一个动画，这样当它的子元素出场时都会具有这个效果。常常用于ListView。</p>
</li>
<li><p>Activity的切换效果：Activity有默认的切换效果，但这个效果也是可以自定义的。主要用到overridePendingTransition(int enterAnim,int exitAnim)这个方法。这个方法必须用在startActivity(Intent)或者finish()之后被调用才能生效。 </p>
</li>
</ol>
</li>
</ul>
<p><em>帧动画</em></p>
<p>   也属于View动画，顺序播放一组预先定义好的图片，帧动画容易引起OOM，所以在使用帧动画时应尽量避免使用尺寸比较大的图片</p>
<p><em>属性动画</em> </p>
<p>  通过在一个时间间隔内完成对象从一个属性值到另一个属性值的改变，从而达到动画的效果。只要对象有这个属性，它都能实现动画效果。</p>
<ul>
<li><p>ValueAnimator</p>
<p> ValueAnimator是整个属性动画机制当中最核心的一个类，负责完成从初始值平滑过渡到结束值，以及负责管理动画的播放次数、播放模式、以及对动画设置监听器等。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> //将值在300毫秒从0过渡到1，并设置监听器不断打印当前值</div><div class="line">    ValueAnimator anim = ValueAnimator.ofFloat(0F,1F);</div><div class="line">    anim.setDuration(300);</div><div class="line">    anim.addUpdateListener(new ValueAnimator. AnimatorUpdateListener()&#123;</div><div class="line"></div><div class="line">@Override  </div><div class="line">public void onAnimationUpdate(ValueAnimator animation) &#123;  </div><div class="line">    float currentValue = (float) animation.getAnimatedValue();  </div><div class="line">    Log.d(&quot;TAG&quot;, &quot;cuurent value is &quot; + currentValue);  </div><div class="line">&#125;  </div><div class="line">     &#125;);</div><div class="line">    </div><div class="line">    anim.start();</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>ObjectAnimator</p>
<p> 继承自ValueAnimator，ValueAnimator只不过是对值进行了一个平滑的动画过渡，但我们实际使用到这种功能的场景好像并不多。而ObjectAnimator则就不同了，它是可以直接对任意对象的任意属性进行动画操作的，但是其底层的动画实现机制也是基于ValueAnimator来完成的。</p>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> //</div><div class="line">  ObjectAnimator animator = ObjectAnimator.ofFloat(textview, &quot;alpha&quot;, 1f, 0f, 1f);  </div><div class="line">animator.setDuration(5000);  </div><div class="line">animator.start();</div></pre></td></tr></table></figure>
</code></pre><ul>
<li>AnimatorSet 动画集合</li>
</ul>
<ul>
<li><p>监听器  </p>
<ol>
<li>Animator类当中提供了一个addListener()方法，这个方法接收一个AnimatorListener，我们只需要去实现这个AnimatorListener就可以监听动画的各种事件了。<br>ObjectAnimator是继承自ValueAnimator的，而ValueAnimator又是继承自Animator的，另外AnimatorSet也是继承自Animator的。所以这个监听器是通用的。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">anim.addListener(new AnimatorListener() &#123;  </div><div class="line">    @Override  </div><div class="line">    public void onAnimationStart(Animator animation) &#123;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public void onAnimationRepeat(Animator animation) &#123;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public void onAnimationEnd(Animator animation) &#123;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public void onAnimationCancel(Animator animation) &#123;  </div><div class="line">    &#125;  </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>   有时候不需要实现这么多方法，为此Android提供了另一个适配器类AnimatorListenerAdapter。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   anim.addListener(new AnimatorListenerAdapter() &#123;  </div><div class="line">    @Override  </div><div class="line">    public void onAnimationEnd(Animator animation) &#123;  </div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li><p>ValueAnimator.AnimatorUpdateListener</p>
<p>该方法监听动画整个过程，每播放一帧，onAnimationUpdate就会被调用一次。 </p>
</li>
</ol>
<p> <em>对属性的要求</em></p>
<p>   属性动画要求动画作用的对象提供该属性的get和set方法</p>
<ol>
<li>对象必须提供set方法，如果没有提供初始值，那么还要提供get方法，因为系统要去取该属性的初始值（如果这条不满足，程序直接crash）</li>
<li>对象的set方法对属性所做的改变必须能够以某种方法反映出来，比如会带来UI的改变。（如果这条不满足，动画无效果但不会crash）  </li>
</ol>
<ul>
<li><p>解决办法</p>
<ol>
<li>如果使用ObjectAnimator，那么就可以用一个类来包装原始对象，间接为其提供get/set方法。</li>
<li>如果使用ValueAnimator，那么就无需get/set方法了，我们可以对一个值做动画，监听整个动画过程，在其中修改对象的属性值。</li>
</ol>
</li>
</ul>
<p>  <em>插值器／估值器</em></p>
<ul>
<li><p>插值器(TimeInterpolator)，它的作用是根据时间流逝的百分比来计算出当前属性改变的百分比。系统预留的有LinearInterpolator（线性插值器，匀速），AccelerateDecelerateInterpolator（加速减速插值器，两头慢中间快），DecelerateInterpolator（减速插值器，越来越慢）</p>
</li>
<li><p>估值器(TypeEvaluator)，它的作用是根据当前属性改变的百分比来计算改变后的属性值。    </p>
</li>
</ul>
<p><strong>谈谈事件分发机制</strong></p>
<ul>
<li><p><code>public boolean dispatchTouchEvent(MotionEvent ev)</code></p>
<p> 负责进行事件的分发，如果事件能够传递给当前view，那么此方法一定会被调用。返回结果表示是否消耗当前事件，true表示消耗，false表示不消耗。</p>
</li>
<li><p><code>public boolean onInterceptTouchEvent(MotionEvent ev)</code><br> 在dispatchTouchEvent方法中调用，用来判断是否拦截某个事件。如果当前View拦截了某个事件，那么在同一事件序列当中，此方法不会再被调用，返回结果表示是否拦截当前事件，true表示拦截，false表示不拦截。</p>
</li>
<li><p><code>public boolean onTouchEvent(MotionEvent ev)</code><br> 在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前view无法再次接受到事件。</p>
</li>
</ul>
<p>  <em>ViewGroup的事件分发过程</em></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">   public boolean dispatchTouchEvent(MotionEvent ev)&#123;</div><div class="line">   </div><div class="line">       final boolean intercepted;</div><div class="line">       //判断是否要拦截当前事件</div><div class="line">       if(当前事件是ACTION_DOWN || 事件已被子元素成功处理) ｛</div><div class="line">       </div><div class="line">        //在子view中通过调用requestDisAllowInterceptTouchEvent方法，可以让父View无法拦截出ACTION_DOWN以外的其它事件</div><div class="line">          final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT!=0);</div><div class="line">          </div><div class="line">          if(!disallowintercept)&#123;</div><div class="line">              intercepted=onInterceptTouchEvent(ev);</div><div class="line">          &#125;else&#123;</div><div class="line">              intercepted=false;</div><div class="line">          &#125;</div><div class="line">       //说明ACTION_DOWN事件被ViewGroup拦截，之后ViewGroup的onInterceptTouchEvent方法不会再被调用，且同一序列的其它事件就会默认交给ViewGroup处理。</div><div class="line">       ｝else&#123;</div><div class="line">          intercepted=true;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       </div><div class="line">     //ViewGroup拦截当前事件</div><div class="line">     if(intercepted)&#123;</div><div class="line">     </div><div class="line">        if(是否设置了OnTouchListener)&#123;</div><div class="line">             onTouch(ev);</div><div class="line">        &#125;else &#123;</div><div class="line">             onTouchEvent(ev);</div><div class="line">             //在onTouchEvent方法中，只要view的clickable或longclickable有一个为true，不管它是不是disable状态，那么它就会消耗当前事件。</div><div class="line">             //当ACTION_UP事件发生，如果view设置了onClickListener，则调用onClick方法;</div><div class="line">             </div><div class="line">        &#125;</div><div class="line">     //ViewGroup不拦截当前事件</div><div class="line">     &#125;else &#123;</div><div class="line">     </div><div class="line">      遍历ViewGroup中的所有子元素，判断是否能够接收当前事件（1.子元素是否在播动画 2。事件坐标是否落在子元素区域内）</div><div class="line">      </div><div class="line">      对于每个子元素，如果接受 则调用childView.disPatchTouchEvent(ev)</div><div class="line">      如果所有子元素均为消耗当前事件，则调用super.disPatchTouchEvent(ev)</div><div class="line">      交给父类处理。</div><div class="line">     </div><div class="line">     </div><div class="line">     &#125;  </div><div class="line">   </div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line"> ``` </div><div class="line"> </div><div class="line"> </div><div class="line"> *View的事件分发过程*  </div><div class="line"> </div><div class="line"> 因为View(这里不包含ViewGroup)是一个单独的元素，它没有子元素因此无法向下传递事件，只需自己处理事件即可。</div></pre></td></tr></table></figure>
<p>  public boolean dispatchTouchEvent(MotionEvent ev){</p>
<pre><code>if(是否设置了OnTouchListener){
           onTouch(ev);
      }else {
           onTouchEvent(ev);
           //在onTouchEvent方法中，只要view的clickable或longclickable有一个为true，不管它是不是disable状态，那么它就会消耗当前事件。
           //当ACTION_UP事件发生，如果view设置了onClickListener，则调用onClick方法;

      }
</code></pre><p>   }</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">  </div><div class="line">  *重要结论*</div><div class="line">     </div><div class="line">   1. 同一事件序列是由ACTION_DOWN --&gt; 若干个ACTION_MOVE --&gt; ACTION_UP组成</div><div class="line">   2. 正常情况下，一个事件序列只能同一个View消耗。</div><div class="line">   3. 对于ViewGroup而言，一旦决定拦截(只能是拦截ACTION_DOWN)，那么这个事件序列都只能交给它来处理，且它的InterceptTouchEvent不会再被调用，直接默认拦截。</div><div class="line">   4. 对于View而言，一旦开始处理事件，如果它不消耗ACTION_DOWN（onTouchEvent返回false），那么同一事件序列的事件也不会再交给它处理。</div><div class="line">   5. 如果View消耗了ACTION_DOWN事件，但是不消耗接下来的其它事件，这些没被消耗的事件不会传递父元素的onTouchEvent处理，而是传递给Activity处理</div><div class="line">   6. View没有onInterceptTouchEvent方法。</div><div class="line">   7. ViewGroup默认不拦截任何事件，源码中ViewGroup的onInterceptTouchEvent方法默认返回false</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">**View的基础知识**</div><div class="line"></div><div class="line">*坐标系*</div><div class="line"></div><div class="line">![坐标系-w531](media/14723648688396/%E5%9D%90%E6%A0%87%E7%B3%BB.png)</div><div class="line"></div><div class="line"></div><div class="line">   </div><div class="line">   * View获取自身坐标：getLeft(),getTop(),getRight(),getBottom()</div><div class="line">   * View获取自身宽高：getHeight(),getWidth()</div><div class="line">   * MotionEvent获取坐标：getX(),getY(),getRawX(),getRawY()</div><div class="line">   </div><div class="line">*MotionEvent*</div><div class="line"></div><div class="line">   代表Android中的事件对象，封装了事件类型，发生时间，位置等。</div><div class="line">   </div><div class="line">*TouchSlop*</div><div class="line"></div><div class="line">   代表系统所能识别出的被认为是滑动的最小距离</div><div class="line">   </div><div class="line">*VelocityTracker*</div><div class="line"></div><div class="line">   用来追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。是通过计算一段时间内手指所划过的像素数得出的。</div><div class="line">   </div><div class="line">*View的滑动*</div><div class="line"></div><div class="line">实现View的滑动，通常使用以下3种方法：</div><div class="line"></div><div class="line">1. 通过View本身的提供的scrollTo/scrollBy实现滑动</div><div class="line">   </div><div class="line">   mScrollX：代表view内容在水平方向的偏移量，大小等于view本身的位置减去view内容的位置。getScrollX()/setScrollX()</div><div class="line">   mScrollY：代表view内容在竖直方向的偏移量，大小等于view本身的位置减去view内容的位置。getScrollY()/setScrollY()</div><div class="line">   </div><div class="line">   scrollTo就是直接改变mScrollX和mScrollY，然后调用onScrollChange方法来通知重绘界面，实现绝对滑动。</div><div class="line">   scrollBy则是直接调用的scrollTo，给mScrollX和mScrollY加上增量。实现相对滑动。</div><div class="line">   scrollTo/scrollBy只能改变view内容的位置而不能改变view在布局中的位置</div><div class="line"> </div><div class="line"> 2. 使用动画给view施加平移效果来实现滑动</div><div class="line">   </div><div class="line">    view动画</div><div class="line">    属性动画</div><div class="line">    </div><div class="line"> 3. 通过改变view的LayoutParams使得view重写布局从而实现滑动</div></pre></td></tr></table></figure>
<pre><code>params = View.getLayoutParams();
params.leftMargin+=100;

View.requestLayout();
</code></pre><p>//或者View.setLayoutParams(params);</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">*View的弹性滑动*</div><div class="line"></div><div class="line">  * 思想：将一次大的滑动分成若干次小的滑动并在一个时间段完成。</div><div class="line">  * 实现方式：</div><div class="line">     </div><div class="line">     1. 使用Scroller</div></pre></td></tr></table></figure>
<pre><code>   Scroller scroller=new Scroller(mContext);
   //startX,startY表示滑动的起点，dx,dy表示滑动的距离，duration代表滑动时间
//startScroll方法内部其实什么也没做，只是保存了我们传递的几个参数。真正触发   view滑动的是invalidate()。invalidate方法会导致View重绘，而在View的draw方法中又会去调用computeScroll方法。其在View中是一个空实现，需要我们自己去实现。
   scroller.startScroll(startX,startY,dx,dy,duration);
   invalidate();


  //view的draw方法中会调用computeScroll方法，而在computeScroll方法又会去获取当前的scrollX和scrollY，然后通过scrollTo方法实现滑动，接着又调用postInvalidate方法进行第二次重绘，这样不断的重绘，直到computeScrollOffset方法返回false，说明整个滑动过程结束。
   @Override
   public void computeScroll(){

     //computeScrollOffset方法会根据时间流逝的百分比来计算出下一次滑动的位置，知道了滑动位置，就可以通过scrollTo来完成view的滑动。
      if(mScroller.computeScrollOffset()){

        scrollTo(mscroller.getCurrX,mscroller.getCurrY);
        postInvalidate();

      }


   }


  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">     </div><div class="line">   2. 通过动画</div><div class="line">   3. 使用延时策略</div><div class="line"></div><div class="line">   </div><div class="line"></div><div class="line">**谈谈View的滑动冲突**   </div><div class="line"></div><div class="line">* 滑动冲突的种类：</div><div class="line">   1. 外部滑动方向与内部滑动方向不一致</div><div class="line">   2. 外部滑动方向与内部滑动方向一致</div><div class="line">   3. 上面两种情况的嵌套</div><div class="line">  </div><div class="line">* 处理规则：</div><div class="line">   1. 对于第一种，主要是根据滑动是水平滑动还是竖直滑动来判断到底由谁来拦截。可以通过判断两点之间的水平距离和竖直距离</div><div class="line">   2. 对于第二种，从业务上来判断    </div><div class="line">    </div><div class="line">* 解决方式：</div><div class="line">   1. 外部拦截法：指点击事件都先经过父容器的拦截处理，父容器需要则拦截，不需要则不拦截。重写父容器的onInterceptTouchEvent方法即可。  </div><div class="line">   2. 内部拦截法：指父容器不拦截任何事情，所有事情都传递给子元素，如果子元素需要则消耗掉，否则就交给父容器进行处理。需要重写子元素的dispatchTouchEvent方法，配合requestDisallowinterceptTouchEvent方法。 </div><div class="line"></div><div class="line">   </div><div class="line">   </div><div class="line"> **谈谈Android的消息机制**</div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line"> *Looper工作原理*</div><div class="line">   </div><div class="line">  * 概念：Looper扮演消息循环的角色，它会不停从MessageQueue中查看是否有新消息，如果有新消息就会立刻处理，否则就会一直阻塞在那里。Looper内部维护了一个消息队列MessageQueue。</div></pre></td></tr></table></figure>

//为当前线程创建Looper
Looper.prepare();
</code></pre><p>   //开始循环处理消息队列<br>    Looper.loop();</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* Looper.loop()</div></pre></td></tr></table></figure>
<p>  for(;;){</p>
<pre><code>//next()是一个阻塞操作，当没有消息时，next()方法会一直阻塞在那里。
Message msg=messageQueue.next();

//loop()是一个死循环，唯一跳出循环的方式是next()方法返回了null。
//Looper.quit()会直接退出Looper
//Looper.quitSafely()只是设定退出标记，然后把消息队列中已有的消息处理完毕后才安全的退出。
if(msg==null){
   return;
}
</code></pre><p>   //msg.target是发送这个消息的handler对象。<br>     msg.target.dispatchMessage(msg);</p>
<p>  }</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">![Loope](media/14723648688396/Looper.png)</div><div class="line"></div><div class="line">  </div><div class="line">  *MessageQueue工作原理*</div><div class="line">  </div><div class="line">   * 消息队列主要包含插入和读取。</div><div class="line">   * 消息队列通过一个单链表来维护消息列表，因为单链表在插入和删除上比较有优势</div><div class="line">   </div><div class="line">   </div><div class="line">  *Handler工作原理*</div><div class="line">  </div><div class="line">     </div><div class="line">  * 概念：Handler的工作主要是发送消息和处理消息(只处理自己发出的消息)。即向MQ中添加消息(sendMessage),并在loop到自己的时候执行该任务(handleMessage)。整个过程是异步的。 Handler创建的时候会关联一个Looper，默认的构造方法是关联当前线程的Looper，不过也可以关联其它线程的Looper。</div><div class="line">  </div><div class="line">![Handle](media/14723648688396/Handler.png)</div><div class="line"></div><div class="line">   </div><div class="line">   </div><div class="line">  * Handler发送消息：</div><div class="line">    </div><div class="line">    post(Runnable),sendMessage(Message)等等。post发出的Runnable对象最后都被封装成Message对象通过send方法发出。</div><div class="line">    </div><div class="line">    Message内部的几个主要属性：</div><div class="line">   1. Handler target； 发送这条消息的handler对象，这确保了looper执行到该message时能找到处理它的handler。</div><div class="line">   2. Runnable callback；对应于通过post方法传递来的Runnable。</div><div class="line">   3. int what;  用户定义的消息识别码</div><div class="line">   4. int arg1，arg2；当只需要传递简单int时，这样比setData(Bundle)代价更低</div><div class="line">   5. Object obj；传输任意对象。如果用于跨进程通信，那么obj得实现了Parcelable接口，对于其他的数据的传输，我们一般使用setData方法就可以了。</div><div class="line">   6. 优先考虑使用Message.obtain()来从消息池中获得空消息对象，以节省资源</div><div class="line"></div><div class="line">    </div><div class="line">   </div><div class="line">  * Handler处理消息</div></pre></td></tr></table></figure>
<p>   public void dispatchMessage(Message msg){</p>
<pre><code>//如果是通过post(Runnable)系列方法发送的消息，则msg中的Runnable callback就会被赋值。那么执行Runnable中的run方法即可。
if(msg.callback != null){
    handleCallback(msg);   
}else｛
   //Callback mCallback是Handler内部的一个接口。
   //如果是通过new Handler(Callback);来创建handler实例，那么 mCallback就不会为null，那么调用Callback接口中的handlerMessage方法即可。
   if(mCallback != null){
        if(mCallback.handlerMessage(msg)){
          return;
           }
  }


｝

//如果上面两种方法都没执行，说明就是继承Handler重写handlerMessage方法
handlerMessage(msg);
</code></pre><p>   }</p>
<p>   private final handlerCallback(Message msg){<br>         msg.callback.run();<br>   }</p>
<p>   public interface Callback{<br>       public boolean handlerMessage(Message msg);<br>   }</p>
<p>   public void handlerMessage(Message msg){<br>   }</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line"> * Handler的用处：</div><div class="line"> </div><div class="line">   1. handler可以在任意线程发送消息，这些消息会被添加到关联的MQ上。</div><div class="line">   2. handler是在它关联的looper线程中处理消息的</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">**ThreadLocal原理**</div><div class="line"></div><div class="line">* Thread类中有一个成员变量ThreadLocal.Values localValues;</div><div class="line">  Values作为ThreadLocal中的内部类，其中有一个数组 Object[] table; 用来在不同线程中维护一套数据的副本并且彼此互不干扰。这样其实ThreadLocal的set和get方法都是操作当前线程的localValues对象的table数组。</div><div class="line">  </div><div class="line">* 当不同线程访问同一个ThreadLocal的get方法时，ThreadLocal内部会从各自线程取出一个数组，然后从数组中根据当先ThreadLocal的索引去查找出对应的value值</div></pre></td></tr></table></figure>
<p>   public T get(){<br>      //取出当前线程的数组<br>      Thread currentThread = Thread.currentThread();<br>      Values values = Values(currentThread);</p>
<pre><code>...
</code></pre><p>   }</p>
<pre><code>Values values(Thread current) {
    return current.localValues;
}
</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"> * ThreadLocal的set方法往table数组中存对象的时候，总是将对象放在ThreadLocal引用的下一个位置。</div><div class="line">   </div><div class="line">   </div><div class="line">   </div><div class="line">   </div><div class="line">**谈谈Android中的多线程** </div><div class="line"></div><div class="line"></div><div class="line">  *HandlerThread* 自带looper的线程</div><div class="line">  </div><div class="line">  *AsyncTask* 对线程池和Handler的封装</div><div class="line">  </div><div class="line">  *IntentService*封装了HandlerThread和Handler</div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line">  **Android签名机制**</div><div class="line">  </div><div class="line">   * 概念：对apk通过一种hash算法(MD5/SHA-1)生成摘要信息，然后利用非对称加密技术，使用私钥对摘要进行加密产生一个字符串。这个字符串就是数字签名。加密算法会保证其他人无法伪造这个字符串。签名会和apk打包在一起。使用者可以使用公钥对这个签名进行解密还原出摘要，然后使用者用相同的hash算法对apk生成一个摘要，与解密后的摘要做对比。如果相同就说明没有被修改。因此数字签名可以保证apk的完整性，</div><div class="line">   * 签名流程：</div><div class="line">   </div><div class="line">    1. 生成MAINFEST.MF文件：遍历apk中的所有文件，利用hash算法生成这些文件的摘要。</div><div class="line">    2. 生成CERT.SF文件：对上面生成的摘要，利用非对称加密算法，使用私钥对摘要进行签名。</div><div class="line">    3. 生成CERT.RSA文件（证书）： CERT.RSA保存了公钥，以及所采用的加密算法，hash算法等。</div><div class="line">    </div><div class="line">    * 结论：</div><div class="line">      </div><div class="line">      1. Android签名机制其实是对apk的完整性和其发布机构唯一性的一种校验机制</div><div class="line">      2. Android签名机制不能阻止对apk包的修改，但修改后再签名无法与原先的签名保持一致（拥有私钥的情况除外）</div><div class="line">      3. 公钥就打包在apk内，且不同的私钥对应不同的公钥，所以可以通过对比公钥，来判断私钥的是否一致，从而判断发布机构的唯一性。（android一般是由应用市场来完成这项工作）</div><div class="line">      4. 上面说的结论都建立在证书是正确的情况下，如果连证书都被替换了，那就没办法了。所以说证书一定要用CA发布的证书（CA会用自己的私钥对开发者的公钥及一些相关信息进行加密，生成数字证书，这样就可以保证开发者的公钥不会被替换），但是android一般都是用的自签名的证书，所以一般就由应用市场来充当ca的角色，应用市场会检验证书的合法性。</div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line">  **使用AIDL**</div><div class="line"></div><div class="line">1. 声明IBookManager.aidl接口，然后编译之后，可以得到对应的IBookManager.java类</div><div class="line">2. 继承IBookManager.stub这个抽象类，实现里面的方法，然后在service中onBind方法中返回这个Binder。AIDL就实现完成了</div><div class="line">3. 然后客户端（Activity）可以在 `public void onServiceConnected(ComponentName name, IBinder service)`中拿到这个Binder对象(驱动给的)，然后通过`IBookManager bookManager=IBookManager.Stub.asInterface(service);` 拿到Binder本地对象或者Binder代理对象。</div><div class="line">```public static com.zj.learn.IBookManager asInterface(android.os.IBinder obj)</div><div class="line">&#123;</div><div class="line">        if ((obj==null)) &#123;</div><div class="line">        return null;</div><div class="line">&#125;</div><div class="line">        //Binder本地对象访问queryLocalInterface才会返回IInterface接口，代表service具有什么样的功能</div><div class="line">        //Binder代理对象访问queryLocalInterface会返回null，因为代理对象没有`this.attachInterface(this,DESCRIPTOR)`</div><div class="line">        android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">        if (((iin!=null)&amp;&amp;(iin instanceof com.zj.learn.IBookManager))) &#123;</div><div class="line">        return ((com.zj.learn.IBookManager)iin);</div><div class="line">        &#125;</div><div class="line">       return new com.zj.learn.IBookManager.Stub.Proxy(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <strong>谈谈binder机制</strong></p>
<p>  <em>通信模型</em></p>
<ol>
<li>Server进程向ServiceManager注册，告诉SM自己是谁，有什么能力。比如它叫zhangsan，有一个object对象(Binder对象)，可以执行add操作。</li>
<li>Client向ServiceManager查询：我需要联系一个叫zhangsan进程里的object对象。但是进程间通信的数据都会经过内核空间的驱动，驱动返回Client进程的对象并不是真正的object对象，而是返回了一个看起来和object一模一样的代理对象objectProxy，这个代理对象也有一个add方法，这个方法只是把参数包装一下直接发给Binder驱动</li>
<li>Binder驱动收到消息后，会把objectProxy对象替换为object对象发送给client，于是Binder驱动通知server进程，调用你object对象的add方法，然后把结果发给我。最后Binder把结果返回给client进程。整个过程就结束了。</li>
</ol>
<p>   <em>IBinder/IInterface/Binder/BinderProxy/Stub</em></p>
<ul>
<li>IBinder是一个接口，它代表了一种跨进程传输的能力；只要实现了这个接口，就能将这个对象进行跨进程传递；这是驱动底层支持的；在跨进程数据流经驱动的时候，驱动会识别IBinder类型的数据，从而自动完成不同进程Binder本地对象以及Binder代理对象的转换。</li>
<li>IInterface也是一个接口，它代表了远程server具有什么样的能力。具体来说，就是aidl里面的接口。</li>
<li>Java层的Binder类，代表的其实就是Binder本地对象。BinderProxy类是Binder类的一个内部类，它代表远程进程的Binder对象的本地代理；这两个类都继承自IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder驱动会自动完成这两个对象的转换。<br>*</li>
</ul>
<p><strong>invaliddate() postinvaliddata() requestLayout()</strong></p>
<p><strong>View的工作原理</strong></p>
<p>   <em>MeasureSpec</em></p>
<ul>
<li>概念：MeasureSpec代表了一个12位的int值，高2位代表SpecMode，低30位代表SpecSize。 SpecSize代表了某种测量模式下的大小，SpecMode指的是测量模式。</li>
<li>测量模式：<ol>
<li>UNSPECIFIED<br>父容器不对view有任何限制，要多大给多大。</li>
<li>EXACTLY（match_parent/具体数值）<br>父容器已经测出view的精确大小</li>
<li>AT_MOST（wrap_content）<br>父容器指定了一个可用大小，view的大小不能超过这个值  </li>
</ol>
</li>
<li>MeasueSpec的生成<br>   MeasureSpec可以理解为建议大小，在measure过程中会根据MeasureSpec来计算出view的测量大小。<br>   对于普通的view，其MeasureSpec是由其父容器的MeasureSpec及自身的LayoutParams决定的。</li>
<li>各种大小的区别：<ol>
<li>建议大小：MeasureSpec代表ViewGroup给childView计算出的建议大小。</li>
<li>测量大小：指的是某次measure过程后的大小，可通过etMeasureWidth(),getMeasureHeight()获得。</li>
<li>最终大小：指的是在layout过程中或之后获得的view的大小，可通过getWidth(),getHeight()方法获得</li>
<li>view的测量大小一般情况下与最终大小相等，但是当出现多次measure才能确定自己的测量大小时，在前几次的测量过程汇中，测量大小可能与最终大小不一致，但最终来说，测量大小还是和最终大小一致。</li>
</ol>
</li>
</ul>
<pre><code>*measure过程*

   &gt; view的measure()

 * view的measure()是final类型的方法，子类不能重写此方法。在其中会调用onMeasure()方法。
 * view的onMeasure()的默认实现：根据MeasureSpec，计算出自身的宽高。即给mMeasureWidth,mMeasureHeight赋值。但是并没有针对wrap_content的情形来处理。因为此时只有childView自己才能计算出自己的大小
 * 可以通过getMeasureWidth(),getMeasureHeight()来获取测量后的大小。
 * 直接继承view的自定义控件需要重写onMeasure()方法并设置wrap_content时的自身大小。

 &gt; ViewGroup的measure()

 * ViewGroup作为View的子类，并没有重写onMeasure()方法，因为不同的ViewGroup的有着不同的布局特性，需要ViewGroup自己来实现。但是ViewGroup同时也提供了多个方法来方便大家完成measure过程。
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">measureChildren(int widthMeasureSpec,int heightMeasureSpec)</div><div class="line">measureChild(View child,int parentWidthMeasureSpec,int</div><div class="line">parentHeightMeasureSpec)</div><div class="line">getChildMeasureSpec(int spec,int padding,int childDimension)</div></pre></td></tr></table></figure>

* ViewGroup的职责：遍历去调用所有子view的measure()方法，完成自身的measure过程。关键是计算出各个子view的MeasureSpec，然后调用childView.measure(),一般计算完所有子元素的大小后，ViewGroup再根据布局特性，完成自己的measure过程。



*layout过程*
*draw过程*
</code></pre><p>  <strong>自定义View</strong>  </p>
<p>  <em>继承View</em>//to-do 添加代码</p>
<ol>
<li>自定义View的属性<br>在res/values/  下建立一个attrs.xml ， 在里面定义我们的属性和声明我们的整个样式。</li>
<li>在View的构造方法中解析自定义属性的值并做相应的处理</li>
<li>重写onMeasure()方法<br>一般来说可以调用父类View的onMeasure()方法，同时增加针对wrap_content的情形处理。</li>
<li>重写onDraw()方法<br> 注意需要添加对padding的处理，不然padding属性无法起作用。   </li>
</ol>
<p><strong>谈谈你对Context的理解</strong></p>
<ul>
<li><p>概念：</p>
<ol>
<li>它描述的是一个应用程序环境的信息，即上下文。</li>
<li>该类是一个抽象类，Android提供了该抽象类的具体实现类(ContextIml类)。</li>
<li>通过它我们可以获取应用程序的资源和类，也包括一些应用级别操作，例如：启动一个Activity，发送广播等</li>
</ol>
</li>
<li><p>结构：<br>   <img src="media/14723648688396/context.png" alt="context"></p>
</li>
</ul>
<pre><code>Context的两个子类分工明确，其中ContextImpl是Context的具体实现类，ContextWrapper是Context的包装类。Activity，Application，Service虽都继承自ContextWrapper（Activity继承自ContextWrapper的子类ContextThemeWrapper），但它们初始化的过程中都会创建ContextImpl对象，由ContextImpl实现Context中的方法。
</code></pre><ul>
<li><p>Context的个数：</p>
<p>  Activity数量＋Service数量＋1（Application） </p>
</li>
<li><p>Context的作用域：</p>
</li>
</ul>
<p><img src="media/14723648688396/context%E4%BD%9C%E7%94%A8%E5%9F%9F.png" alt="context作用域"></p>
<pre><code>凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以
</code></pre><ul>
<li><p>如何获取Context：</p>
<ol>
<li>View.getContext,返回当前View对象的Context对象，通常是当前正在展示的Activity对象</li>
<li>Activity.getApplicationContext,获取当前Activity所在的(应用)进程的Context对象，通常我们使用Context对象时，要优先考虑这个全局的进程Context（Application）</li>
<li><p>Activity.this 返回当前的Activity实例</p>
<p><em>getApplication()和getApplicationContext()</em><br>二者都是拿到Application，是同一个对象。区别在于作用域不同：getApplication()只能在Activity和Service中才能调用得到。</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>正确使用Context：</p>
<p>   一般Context造成的内存泄漏，几乎都是当Context需要被销毁的时候，却因为被引用导致销毁失败。</p>
<ol>
<li>当Application的Context能搞定的情况下，并且生命周期长的对象，优先使用Application的Context。</li>
<li>不要让生命周期长于Activity的对象持有到Activity的引用。</li>
<li>尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐式持有外部类实例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有。</li>
</ol>
</li>
</ul>
<p><strong>设备横竖屏切换的时候，接下来会发生什么</strong></p>
<ul>
<li>不设置Activity的android:configChanges时，切屏会重新调用各个生命周期</li>
<li>设置Activity的android:configChanges=”orientation|screenSize”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</li>
</ul>
<p><strong>Android中的内存泄露</strong></p>
<ul>
<li>概念：指的是进程中某些对象（垃圾对象）已经没有使用价值了，但是它们却可以直接或间接地引用到gc roots导致无法被GC回收。无用的对象占据着内存空间，使得实际可使用内存变小，形象地说法就是<br>了。本质上是由于长生命周期的对象引用到短生命周期的对象造成的。</li>
<li>场景：<ol>
<li>类的静态变量持有大数据对象<br>静态变量长期维持到大数据对象的引用，阻止垃圾回收。</li>
<li>非静态内部类<br>非静态内部类会维持一个到外部类实例的引用，如果非静态内部类的实例是静态的，就会间接长期维持着外部类的引用，阻止被回收掉。再比如，在Activity中使用非静态的内部类，并在内部类中开启一个长时间运行的线程，因为内部类持有Activity的引用，会导致Activity本来可以被gc时却长期得不到回收<ol>
<li>资源对象未关闭<br>资源性对象如Cursor、File、Socket，应该在使用后及时关闭。未在finally中关闭，会导致异常情况下资源对象未被释放的隐患</li>
<li>注册对象未反注册<br>未反注册会导致观察者列表里维持着对象的引用，阻止垃圾回收。例如，未反注册会导致观察者列表里维持着对象的引用，阻止垃圾回收。</li>
<li>Handler临时性内存泄露<br>Handler通过发送Message与主线程交互，Message发出之后是存储在MessageQueue中的，有些Message也不是马上就被处理的。在Message中存在一个 target，是Handler的一个引用，如果Message在Queue中存在的时间越长，就会导致Handler无法被回收。如果Handler是非静态内部类，则会导致Activity或者Service不会被回收。存在一条Message–Handler–Activity的引用链。同时如果Runnable（Runable会被封装成Message）也是非静态内部类，也会持有对Activity的引用。由于AsyncTask内部也是Handler机制，同样存在内存泄漏的风险。</li>
</ol>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>预防:</p>
<ol>
<li>不要维持到Activity的长久引用，对activity的引用应该和activity本身有相同的生命周期。</li>
<li>尽量使用context-application代替context-activity</li>
<li>Activity中尽量不要使用非静态内部类，可以使用静态内部类和WeakReference代替。</li>
</ol>
</li>
<li><p>检测：<br>  DDMS，MAT     </p>
</li>
</ul>
<p><strong>Android中的内存溢出(OOM)</strong></p>
<p>   Bitmap是android中经常使用的一个类，它代表了一个图片资源，Bitmap消耗内存很严重，如果不注意优化代码，经常会出现OOM问题。</p>
<ul>
<li><p>优化：</p>
<p><em>压缩图片</em></p>
<ol>
<li>将BitMapFactory.Options的inJustDecodeBounds参数设为true并加载图片。</li>
<li>从BitMapFactory.Options中取出图片的原始宽高信息(outWidth/outHeight)</li>
<li>根据采样率的规则并结合目标View的所需大小计算出采样率inSampleSize。</li>
<li>将BitMapFactory.Options的inJustBounds参数设为false，然后重新加载。</li>
</ol>
</li>
</ul>
<pre><code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">  public static Bitmap decodeSampledBitmapFromResource(Resources res,int resId,int reqWidth,int reqHeight)&#123;</div><div class="line">  </div><div class="line">  finaln BitmapFactory.Options options=new BitmapFactory.Options();</div><div class="line">  options.inJustDecodeBounds=true;</div><div class="line">  BitmapFactory.decodeResource(res,resId,options);</div><div class="line">  </div><div class="line">  options.inSampleSize=caculateInSampleSize(options,reqWidth,reqHeight);</div><div class="line">  options.inJustDecodeBounds=false;</div><div class="line">  return BitmapFactory.decodeResource(res,resId,options);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  public static calculateInSampleSize(BitmapFactory.Options options,int reqWidth,int reqHeight)&#123;</div><div class="line">  </div><div class="line">  final int height=options.outHeight;</div><div class="line">  final int width=options.outWidth;</div><div class="line">  int inSampleSize=1;</div><div class="line">  </div><div class="line">  if(height&gt;reqHeight||width&gt;reqWidth)&#123;</div><div class="line">  final halfHeight=height/2;</div><div class="line">  final halfWidth=width/2;</div><div class="line">  </div><div class="line">  while(halfHeight/inSampleSize&gt;=reqHeight&amp;&amp;halfWidth/inSampleSize&gt;=reqWidth)&#123;</div><div class="line">    inSampleSize*=2;</div><div class="line">   &#125;</div><div class="line">  </div><div class="line">  &#125;</div><div class="line">     return inSampleSize;</div><div class="line">&#125;</div></pre></td></tr></table></figure>






*使用缓存*

  LruCache用于实现内存缓存，DiskLruCache用于实现磁盘缓存。

 1. LruCache (最近最少使用算法)
     从Android3.1开始，LruCache已经时android源码的一部分了。基于LinkedHashMap实现的，将其accessOrder设置为true，表示按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。这样当缓存满时，就可以移除较早使用的缓存对象（表头）。

 2. DiskCache 


*及时回收*

至于什么时候需要手动调用bitmap.recycle()，这就看具体场景了，原则是当我们不再使用Bitmao时，需要回收之。 
2.3之前Bitmap对象与像素数据是分开存放的，Bitmap对象存在java Heap中而像素数据存放在Native Memory中，这时很有必要调用recycle回收内存。
但是2.3之后，Bitmap对象和像素数据都是存在Heap中，GC可以回收其内存。
</code></pre><p>  <strong>说说推送</strong></p>
<ul>
<li>概念：通过心跳机制维持一个长连接。维护任何一个长连接都需要心跳机制，客户端发送一个心跳给服务器，服务器给客户端一个心跳应答，这样就形成客户端服务器的一次完整的握手，这个握手是让双方都知道他们之间的连接是没有断开，客户端是在线的。如果超过一个时间的阈值，客户端没有收到服务器的应答，或者服务器没有收到客户端的心跳，那么对客户端来说则断开与服务器的连接重新建立一个连接，对服务器来说只要断开这个连接即可。</li>
<li>国内移动网络运营商的特点：因为IPv4的IP量有限，运营商分配给手机终端的IP是运营商内网的IP，手机要连接Internet，就需要通过运营商的网关做一个网络地址转换(Network Address Translation，NAT)。简单的说运营商的网关需要维护一个外网IP、端口到内网IP、端口的对应关系，以确保内网的手机可以跟Internet的服务器通讯。<br>大部分移动无线网络运营商都在链路一段时间没有数据通讯时，会淘汰NAT表中的对应项，造成链路中断。因此运营商采取的是刻意缩短空闲连接的释放超时，来节省信道资源，但是这种刻意释放的行为让这些推送app不得不以高于平常的频率来发送心跳来维护推送的长连接。<br>这样造成了如下缺陷：<ol>
<li>信道资源的浪费</li>
<li>耗电量的上升</li>
</ol>
</li>
<li>如何优化：<br> 自适应心跳间隔优化：从当前成功的心跳间隔开始，逐渐增加间隔去试探最大的心跳间隔。（对于每次试探，成功一次就可以继续增加间隔试探，连续失败多次才算失败）</li>
</ul>
<p><strong>说说https</strong></p>
<ul>
<li>概念：https＝http＋ssl,ssl中用到了非对称加密算法，对称加密算法，hash算法。非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而hash算法用于验证数据的完整性</li>
<li>原理：和http一样，也同样包含两个阶段：握手，数据传输。<ol>
<li>握手：在握手的同时双方会协商出一个会话密钥（非对称加密）</li>
<li>数据传输：使用握手阶段协商出的密钥进行加密传输（对称加密）</li>
</ol>
</li>
</ul>
<pre><code>![https](media/14723648688396/https.png)
</code></pre><p> <strong>说说android使用卡顿是什么造成的，给出优化</strong></p>
<ul>
<li><p>原因：</p>
<ol>
<li>主线程干的活太多了，导致没时间来响应用户的操作（可能导致ANR）</li>
<li>View过度渲染(overdraw),导致某些像素在同一帧的时间内被绘制了多次，这就浪费大量的CPU以及GPU资源。</li>
<li>布局过于复杂，无法在16ms内完成渲染</li>
<li>View频繁的触发measure，layout，导致measure，layout累计耗时过多及整个View频繁的重新渲染</li>
</ol>
<ul>
<li>优化：<ol>
<li>布局优化：<br> <include>标签 ：主要用来复用布局文件<br> <merge>标签 ：一般与<include>标签一起使用从而减少布局的层级，当LayoutInflater遇到<merge>标签时，它会跳过它，并将<merge>内的元素添加到<merge>的父元素里。<br> <viewstub>标签：ViewStub继承了View，它非常轻量级且宽高都是0，因此它本身不参与任何布局的绘制过程。意义在于按需加载所需的布局文件。<br> 工具： hierarchy viewer 可以很方便的查看当前界面的布局的层次结构。</viewstub></merge></merge></merge></include></merge></include></li>
<li>响应速度优化：<br>  Android Studio引入了对traceview的支持，利用它可以记录你操作app的过程中所有方法的调用栈，会生成一张图表，X轴代表时间，Y轴代表方法调用的堆栈，假设我们想找出来什么东西阻塞了UI，那就很容易定位到占用时间的方法。</li>
</ol>
</li>
</ul>
<ol>
<li>绘制优化：针对的是View的onDraw方法。<pre><code>首先，onDraw中不要创建新的局部对象，因为onDraw方法可能会被频繁调用，这样会在一瞬间产生大量临时对象。
其次，onDraw中不要做耗时的任务，这样会导致view的绘制过程不流畅，无法在16ms内完成渲染。
</code></pre></li>
</ol>
</li>
</ul>
<p>  <strong>ANR是什么？怎样避免和解决ANR</strong></p>
<ul>
<li>ANR : Application Not Responding，即应用无响应</li>
<li><p>类型 : </p>
<ol>
<li>KeyDispatchTimeout(5 seconds) –主要类型<br>按键或触摸事件在特定时间内无响应</li>
<li>BroadcastTimeout(10 seconds)</li>
<li>ServiceTimeout(20 seconds) –小概率类型</li>
</ol>
</li>
<li><p>原因 :</p>
<ol>
<li>当前的事件没有机会得到处理（UI线程正在处理前一个事件没有及时完成或者looper被某种原因阻塞住）</li>
<li><p>当前的事件正在处理，但没有及时完成</p>
<p>UI线程尽量只做跟UI相关的工作，耗时的工作（数据库操作，I/O，连接网络或者其他可能阻碍UI线程的操作）放入单独的线程处理，尽量用Handler来处理UI thread和thread之间的交互。</p>
</li>
</ol>
</li>
<li><p>排查 :</p>
<ol>
<li>导出/data/data/anr/traces.txt，找出函数和调用过程，分析代码</li>
<li>分析log     </li>
</ol>
</li>
</ul>
<p><strong>View与View Group分类。自定义View过程：onMeasure()、onLayout()、onDraw()。</strong></p>
<p>如何自定义控件：</p>
<ol>
<li><p>自定义属性的声明和获取</p>
<ul>
<li>分析需要的自定义属性</li>
<li>在res/values/attrs.xml定义声明</li>
<li>在layout文件中进行使用</li>
<li>在View的构造方法中进行获取       </li>
</ul>
</li>
<li>测量onMeasure</li>
<li>布局onLayout(ViewGroup)</li>
<li>绘制onDraw</li>
<li>onTouchEvent</li>
<li>onInterceptTouchEvent(ViewGroup)</li>
<li>状态的恢复与保存</li>
</ol>
<hr>
<hr>
<p><strong>你用过什么框架，是否看过源码，是否知道底层原理。</strong></p>
<p>Retrofit</p>
<p>EventBus</p>
<p>glide</p>
<hr>
<p><strong>Android5.0、6.0新特性。</strong></p>
<p>Android5.0新特性：</p>
<ul>
<li>MaterialDesign设计风格</li>
<li>支持多种设备</li>
<li>支持64位ART虚拟机</li>
</ul>
<p>Android6.0新特性</p>
<ul>
<li>大量漂亮流畅的动画</li>
<li>支持快速充电的切换</li>
<li>支持文件夹拖拽应用</li>
<li>相机新增专业模式</li>
</ul>
<p>Android7.0新特性</p>
<ul>
<li>分屏多任务</li>
<li>增强的Java8语言模式</li>
<li>夜间模式</li>
</ul>
<hr>
<p><strong>Context区别</strong></p>
<ul>
<li>Activity和Service以及Application的Context是不一样的,Activity继承自ContextThemeWraper.其他的继承自ContextWrapper</li>
<li>每一个Activity和Service以及Application的Context都是一个新的ContextImpl对象</li>
<li>getApplication()用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法，getApplicationContext()比getApplication()方法的作用域会更广一些，任何一个Context的实例，只要调用getApplicationContext()方法都可以拿到我们的Application对象。</li>
<li>Activity在创建的时候会new一个ContextImpl对象并在attach方法中关联它，Application和Service也差不多。ContextWrapper的方法内部都是转调ContextImpl的方法</li>
<li>创建对话框传入Application的Context是不可以的</li>
<li>尽管Application、Activity、Service都有自己的ContextImpl，并且每个ContextImpl都有自己的mResources成员，但是由于它们的mResources成员都来自于唯一的ResourcesManager实例，所以它们看似不同的mResources其实都指向的是同一块内存</li>
<li>Context的数量等于Activity的个数 + Service的个数 + 1，这个1为Application</li>
</ul>
<hr>
<p><strong>IntentService的使用场景与特点。</strong></p>
<blockquote>
<p>IntentService是Service的子类，是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁Service的问题</p>
</blockquote>
<p>优点：</p>
<ul>
<li>一方面不需要自己去new Thread</li>
<li>另一方面不需要考虑在什么时候关闭该Service</li>
</ul>
<p>onStartCommand中回调了onStart，onStart中通过mServiceHandler发送消息到该handler的handleMessage中去。最后handleMessage中回调onHandleIntent(intent)。</p>
<hr>
<p><strong>图片缓存</strong></p>
<p>查看每个应用程序最高可用内存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);  </div><div class="line">Log.d(&quot;TAG&quot;, &quot;Max memory is &quot; + maxMemory + &quot;KB&quot;);</div></pre></td></tr></table></figure>
<hr>
<p><strong>Gradle</strong></p>
<p>构建工具、Groovy语法、Java</p>
<p>Jar包里面只有代码，aar里面不光有代码还包括</p>
<hr>
<p><strong>你是如何自学Android</strong></p>
<p>首先是看书和看视频敲代码，然后看大牛的博客，做一些项目，向github提交代码，觉得自己API掌握的不错之后，开始看进阶的书，以及看源码，看完源码学习到一些思想，开始自己造轮子，开始想代码的提升，比如设计模式，架构，重构等。</p>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="2016/10/01/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-01T13:40:31+08:00" content="2016-10-01">
              2016-10-01
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="th0_sky" />
          <p class="site-author-name" itemprop="name">th0_sky</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">2</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">th0_sky</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
